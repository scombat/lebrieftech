---
title: "Migrer de Borsh Manuel à LUMOS : Guide pas-à-pas"
seoTitle: "Tutoriel: Migrer de Borsh manuel à LUMOS facilement [Guide pas-à-pas]"
seoDescription: "Optimisez vos projets Rust et TypeScript en migrant de Borsh manuel à LUMOS. Réduction des bugs, synchronisation des types et gain de temps assurés."
datePublished: Wed Dec 17 2025 23:40:05 GMT+0000 (Coordinated Universal Time)
cuid: cmjanm92m000002l2h6b405jp
slug: migrer-de-borsh-manuel-a-lumos-guide
canonical: https://dev.to/getlumos/migrating-from-manual-borsh-to-lumos-a-step-by-step-guide-444g

---

# Migrer de Borsh Manuel à LUMOS : Guide pas-à-pas

## TL;DR

- LUMOS simplifie la synchronisation des types entre Rust et TypeScript et réduit la maintenance.
- Il permet une compatibilité binaire avec Borsh tout en minimisant les risques de bugs.
- Une migration typique peut être réalisée en 5 à 30 minutes par struct ou enum.
- Ce guide détaille les étapes nécessaires pour une migration progressive et sécurisée.
- L'intégration CI/CD est un moyen efficace d’assurer une transition fluide.

## Pourquoi migrer ?

Borsh est une bibliothèque populaire pour la sérialisation binaire utilisée dans de nombreux projets Rust. Cependant, son utilisation manuelle peut rapidement devenir un casse-tête, notamment lorsqu’il s’agit de synchroniser des types entre Rust et TypeScript dans des projets exploitant des smart contracts ou des API complexes. 

En revanche, LUMOS est conçu pour rationaliser ce processus et réduire les risques liés à la maintenance. Il automatise la génération de types entre les deux langages tout en conservant une compatibilité binaire avec vos données et en limitant les erreurs. Migrer vers LUMOS permet ainsi de gagner du temps et d’augmenter la fiabilité de vos projets.

## Étape 1 : Audit de votre code existant

Avant de démarrer la migration, il est crucial d’examiner votre code pour identifier les parties pertinentes utilisant Borsh. Voici les éléments à analyser :

- **Les structs et enums sérialisés avec Borsh** : Notez les endroits où le trait `BorshSerialize` ou `BorshDeserialize` est utilisé.
- **Les tests et les vérifications de compatibilité** : Recensez les tests de sérialisation/désérialisation, ainsi que les portions de code manipulant directement les données binaires générées.
- **Interactions TypeScript** : Vérifiez les fichiers TypeScript qui interprètent les données issues de Borsh, ainsi que les définitions de types associées.

Une fois votre audit terminé, notez les structures les plus complexes ou sensibles, car elles nécessiteront une attention particulière pendant la migration.

## Étape 2 : Exemple Avant/Après

Pour bien comprendre les avantages de LUMOS, voici un exemple de transformation d’une struct Rust et de son équivalent en TypeScript.

### Avant : Borsh manuel

```rust
use borsh::{BorshDeserialize, BorshSerialize};

#[derive(BorshSerialize, BorshDeserialize)]
pub struct User {
    pub id: u64,
    pub name: String,
    pub email: String,
}
```

En TypeScript, les développeurs définissent une structure correspondante manuellement :

```typescript
export interface User {
  id: number;
  name: string;
  email: string;
}
```

Ce processus nécessite une bonne synchronisation entre le code Rust et TypeScript, ce qui est sujet à des erreurs humaines. Par exemple, une modification dans la struct Rust peut rendre obsolètes les définitions TypeScript correspondantes sans qu’il soit évident de détecter ces inconsistances.

### Après : Migration vers LUMOS

Avec LUMOS, voici comment vous pourriez simplifier le processus :

```rust
use lumos::{LumosSerialize};

#[derive(LumosSerialize)]
pub struct User {
    pub id: u64,
    pub name: String,
    pub email: String,
}
```

LUMOS génère automatiquement les définitions TypeScript correspondantes avec la commande de son CLI :

```bash
lumos-gen-types --input ./src/main.rs --output ./types/generated.ts
```

Le fichier TypeScript produit inclut automatiquement la struct définie dans Rust :

```typescript
export interface User {
  id: number;
  name: string;
  email: string;
}
```

Ce mécanisme élimine la charge de synchronisation manuelle entre les langages.

## Étape 3 : Mettre à jour les importations

Après avoir adopté LUMOS, il faut ajuster les imports dans votre projet. Par exemple, remplacez :

```rust
use borsh::{BorshSerialize, BorshDeserialize};
```

Par :

```rust
use lumos::{LumosSerialize};
```

Assurez-vous également de mettre à jour les fichiers TypeScript pour qu'ils utilisent les nouveaux types générés par LUMOS. Cela garantit que tout le projet est bien aligné avec les définitions générées.

## Étape 4 : Vérification de la compatibilité binaire

La migration vers LUMOS génère des fichiers binaires compatibles avec Borsh. Cependant, il est important de vérifier que vos structures migrées produisent bien la même sortie binaire pour éviter les régressions dans les projets existants.

Ajoutez des tests qui comparent les fichiers générés par Borsh et LUMOS pour la même structure :

```rust
#[test]
fn test_binary_compatibility() {
    let user = User {
        id: 1,
        name: String::from("Alice"),
        email: String::from("alice@example.com"),
    };

    let borsh_binary = user.try_to_vec().unwrap(); // Borsh
    let lumos_binary = lumos::serialize(&user); // LUMOS

    assert_eq!(borsh_binary, lumos_binary); 
}
```

Ces tests éviteront tout problème en production avec d’anciennes données déjà sérialisées en Borsh.

## Stratégie de migration progressive

Il n'est pas nécessaire de migrer tout votre projet d’un seul coup. Pour réduire les risques, procédez de manière incrémentielle :

1. **Ciblez les structures les moins utilisées** : Commencez par migrer les types qui ont peu d’impact sur les autres composants.
2. **Intégration des types LUMOS** : Migrez les types Rust vers LUMOS, puis générez leurs contreparties TypeScript avec le CLI.
3. **Validez au fur et à mesure** : Ajoutez des tests de compatibilité binaire et assurez-vous que les parties intégrées fonctionnent correctement avant de passer aux suivantes.

Cette approche permet de minimiser les interruptions dans le développement et les problèmes en production.

## Intégration CI/CD

Pour garantir un processus de migration fluide et prévenir les regressions, incluez LUMOS dans vos pipelines CI/CD. Voici quelques étapes à suivre :

1. **Ajoutez un job générant automatiquement les types TypeScript** :
   Configurez votre pipeline pour exécuter la commande `lumos-gen-types` et vérifier que les fichiers générés sont intégrés dans le contrôle de version.

2. **Automatisez la validation de compatibilité binaire** :
   Ajoutez des tests dans votre pipeline pour vérifier que les fichiers LUMOS sont compatibles avec les données existantes de Borsh. Voici un exemple de configuration avec Rust:

```yaml
jobs:
  verify-binary-compatibility:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/toolchain@v1
      - run: cargo test -- --test test_binary_compatibility
```

3. **Veillez aux contrôles de cohérence des types** :
   Intégrez une étape qui assure que les fichiers TypeScript produits sont synchronisés avec les types Rust.

Avec cette approche, vous réduisez significativement les risques liés à la migration, tout en automatisant les opérations répétitives.

---

En suivant ce guide pas-à-pas, vous faciliterez la transition de vos projets de Borsh manuel à LUMOS tout en préservant la stabilité et la compatibilité de votre code.

[source](https://dev.to/getlumos/migrating-from-manual-borsh-to-lumos-a-step-by-step-guide-444g)